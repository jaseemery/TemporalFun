using Microsoft.Extensions.Logging;
using Moq;
using FluentAssertions;
using Xunit;
using TemporalWorkerApp.Loaders;
using TemporalWorkerApp.Managers;
using TemporalWorkerApp.Watchers;
using Temporalio.Workflows;
using System.Reflection;

namespace TemporalWorker.Tests;

public class WorkflowHotReloadTests : IDisposable
{
    private readonly Mock<ILogger<WorkflowLoader>> _mockLogger;
    private readonly Mock<ILogger<HotReloadManager>> _mockHotReloadLogger;
    private readonly Mock<ILogger<PackageWatcher>> _mockPackageWatcherLogger;
    private readonly HotReloadManager _hotReloadManager;
    private readonly WorkflowLoader _workflowLoader;

    public WorkflowHotReloadTests()
    {
        _mockLogger = new Mock<ILogger<WorkflowLoader>>();
        _mockHotReloadLogger = new Mock<ILogger<HotReloadManager>>();
        _mockPackageWatcherLogger = new Mock<ILogger<PackageWatcher>>();
        
        _hotReloadManager = new HotReloadManager(_mockHotReloadLogger.Object, _mockPackageWatcherLogger.Object);
        _workflowLoader = new WorkflowLoader(_mockLogger.Object, _hotReloadManager);
    }

    [Fact]
    public void WorkflowDetection_ShouldIdentifyWorkflowAttribute()
    {
        // Arrange
        var workflowType = typeof(AttributeBasedWorkflow);

        // Act
        var isWorkflow = IsWorkflowTypeAccessible(workflowType);

        // Assert
        isWorkflow.Should().BeTrue("Type with [Workflow] attribute should be detected");
    }

    [Fact]
    public void WorkflowDetection_ShouldIdentifyWorkflowNaming()
    {
        // Arrange
        var workflowType = typeof(NamingBasedWorkflow);

        // Act
        var isWorkflow = IsWorkflowTypeAccessible(workflowType);

        // Assert
        isWorkflow.Should().BeTrue("Type ending with 'Workflow' should be detected");
    }

    [Fact]
    public void WorkflowDetection_ShouldIgnoreNonWorkflowTypes()
    {
        // Arrange
        var nonWorkflowType = typeof(RegularClass);

        // Act
        var isWorkflow = IsWorkflowTypeAccessible(nonWorkflowType);

        // Assert
        isWorkflow.Should().BeFalse("Regular class should not be detected as workflow");
    }

    [Fact]
    public async Task WorkflowHotReload_ShouldDetectNewWorkflows()
    {
        // Arrange
        var detectedWorkflows = new List<Type>();
        _workflowLoader.WorkflowsChanged += workflows => detectedWorkflows.AddRange(workflows);

        var newWorkflows = new List<Type> 
        { 
            typeof(AttributeBasedWorkflow), 
            typeof(NamingBasedWorkflow) 
        };

        // Act
        _hotReloadManager.WorkflowsReloaded?.Invoke(newWorkflows);

        // Assert
        detectedWorkflows.Should().HaveCount(2);
        detectedWorkflows.Should().Contain(typeof(AttributeBasedWorkflow));
        detectedWorkflows.Should().Contain(typeof(NamingBasedWorkflow));
    }

    [Fact]
    public async Task LoadWorkflowsWithHotReload_ShouldReturnWorkflowTypes()
    {
        // Arrange & Act
        var workflows = await _workflowLoader.LoadWorkflowsWithHotReloadAsync();

        // Assert
        workflows.Should().NotBeNull();
        workflows.Should().BeAssignableTo<IEnumerable<Type>>();
    }

    [Fact]
    public void WorkflowLoader_ShouldHandleMultipleEventSubscriptions()
    {
        // Arrange
        var eventCount = 0;
        var handler1 = new Action<IEnumerable<Type>>(_ => eventCount++);
        var handler2 = new Action<IEnumerable<Type>>(_ => eventCount++);

        _workflowLoader.WorkflowsChanged += handler1;
        _workflowLoader.WorkflowsChanged += handler2;

        // Act
        _hotReloadManager.WorkflowsReloaded?.Invoke(new List<Type> { typeof(AttributeBasedWorkflow) });

        // Assert
        eventCount.Should().Be(2, "Both event handlers should be called");

        // Cleanup - Unsubscribe to prevent side effects
        _workflowLoader.WorkflowsChanged -= handler1;
        _workflowLoader.WorkflowsChanged -= handler2;
    }

    [Fact]
    public void LoadWorkflowsFromAssemblies_ShouldFilterSystemAssemblies()
    {
        // Arrange
        var logger = Mock.Of<ILogger>();

        // Act
        var workflows = WorkflowLoader.LoadWorkflowsFromAssemblies(logger);

        // Assert
        workflows.Should().NotBeNull();
        
        // Should not contain workflows from system assemblies
        var workflowList = workflows.ToList();
        workflowList.Should().NotContain(w => w.Assembly.FullName?.StartsWith("System") == true);
        workflowList.Should().NotContain(w => w.Assembly.FullName?.StartsWith("Microsoft") == true);
    }

    [Fact]
    public void WorkflowLoader_ShouldHandleDisposalGracefully()
    {
        // Arrange
        var disposed = false;

        // Act
        _workflowLoader.Dispose();
        disposed = true;

        // Assert
        disposed.Should().BeTrue();
        
        // Should not throw when disposed multiple times
        var act = () => _workflowLoader.Dispose();
        act.Should().NotThrow();
    }

    [Fact]
    public async Task ConcurrentWorkflowReloads_ShouldNotCauseRaceConditions()
    {
        // Arrange
        var eventCount = 0;
        var lockObject = new object();
        
        _workflowLoader.WorkflowsChanged += workflows =>
        {
            lock (lockObject)
            {
                eventCount++;
            }
        };

        var tasks = new List<Task>();

        // Act - Trigger multiple concurrent reloads
        for (int i = 0; i < 10; i++)
        {
            tasks.Add(Task.Run(() => 
            {
                _hotReloadManager.WorkflowsReloaded?.Invoke(new List<Type> { typeof(AttributeBasedWorkflow) });
            }));
        }

        await Task.WhenAll(tasks);

        // Assert
        eventCount.Should().Be(10, "All concurrent events should be handled");
    }

    // Helper method to access the private IsWorkflowType method
    private bool IsWorkflowTypeAccessible(Type type)
    {
        // Use reflection to access private method for testing
        var method = typeof(WorkflowLoader).GetMethod("IsWorkflowType", 
            BindingFlags.NonPublic | BindingFlags.Static);
        
        if (method != null)
        {
            return (bool)method.Invoke(null, new object[] { type })!;
        }
        
        // Fallback implementation for testing
        return type.GetCustomAttribute<WorkflowAttribute>() != null || 
               type.Name.EndsWith("Workflow") && type.IsClass && !type.IsAbstract;
    }

    public void Dispose()
    {
        _workflowLoader?.Dispose();
        _hotReloadManager?.Dispose();
    }
}

// Test workflow classes
[Workflow("attribute-based")]
public class AttributeBasedWorkflow
{
    [WorkflowRun]
    public async Task<string> RunAsync()
    {
        await Task.Delay(10);
        return "attribute-based";
    }
}

public class NamingBasedWorkflow
{
    public async Task<string> RunAsync()
    {
        await Task.Delay(10);
        return "naming-based";
    }
}

public class RegularClass
{
    public void DoSomething()
    {
        // Not a workflow
    }
}

public abstract class AbstractWorkflow
{
    // Should be ignored as it's abstract
}