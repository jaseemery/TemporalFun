using Microsoft.Extensions.Logging;
using Moq;
using FluentAssertions;
using Xunit;
using TemporalWorkerApp.Loaders;
using TemporalWorkerApp.Managers;
using TemporalWorkerApp.Watchers;
using Temporalio.Activities;
using System.Reflection;

namespace TemporalWorker.Tests;

public class ActivityLoaderTests : IDisposable
{
    private readonly Mock<ILogger<ActivityLoader>> _mockLogger;
    private readonly Mock<ILogger<HotReloadManager>> _mockHotReloadLogger;
    private readonly Mock<ILogger<PackageWatcher>> _mockPackageWatcherLogger;
    private readonly ActivityLoader _activityLoader;

    public ActivityLoaderTests()
    {
        _mockLogger = new Mock<ILogger<ActivityLoader>>();
        _mockHotReloadLogger = new Mock<ILogger<HotReloadManager>>();
        _mockPackageWatcherLogger = new Mock<ILogger<PackageWatcher>>();
        
        _activityLoader = new ActivityLoader(
            _mockLogger.Object,
            _mockHotReloadLogger.Object,
            _mockPackageWatcherLogger.Object
        );
    }

    [Fact]
    public void Constructor_ShouldInitializeProperly()
    {
        // Arrange & Act & Assert
        _activityLoader.Should().NotBeNull();
        _activityLoader.HotReloadManager.Should().NotBeNull();
    }

    [Fact]
    public void HotReloadManager_ShouldBeExposed()
    {
        // Arrange & Act
        var hotReloadManager = _activityLoader.HotReloadManager;

        // Assert
        hotReloadManager.Should().NotBeNull();
        hotReloadManager.Should().BeOfType<HotReloadManager>();
    }

    [Fact]
    public async Task LoadActivitiesWithHotReloadAsync_ShouldReturnDelegates()
    {
        // Arrange & Act
        var activities = await _activityLoader.LoadActivitiesWithHotReloadAsync();

        // Assert
        activities.Should().NotBeNull();
        activities.Should().BeAssignableTo<IEnumerable<Delegate>>();
    }

    [Fact]
    public void LoadActivitiesFromAssemblies_ShouldReturnActivities()
    {
        // Arrange
        var logger = Mock.Of<ILogger>();

        // Act
        var activities = ActivityLoader.LoadActivitiesFromAssemblies(logger);

        // Assert
        activities.Should().NotBeNull();
        activities.Should().BeAssignableTo<IEnumerable<Delegate>>();
    }

    [Fact]
    public void LoadActivitiesFromAssemblies_ShouldFindActivityMethods()
    {
        // Arrange
        var logger = Mock.Of<ILogger>();

        // Act
        var activities = ActivityLoader.LoadActivitiesFromAssemblies(logger);
        var activityList = activities.ToList();

        // Assert
        activityList.Should().NotBeEmpty("Should find at least some activities");
    }

    [Fact]
    public void ActivitiesChanged_EventShouldBeTriggered()
    {
        // Arrange
        var eventTriggered = false;
        var receivedActivities = new List<Delegate>();

        _activityLoader.ActivitiesChanged += (activities) =>
        {
            eventTriggered = true;
            receivedActivities.AddRange(activities);
        };

        var testActivities = new List<Delegate> { new Action(() => { }) };

        // Act
        _activityLoader.HotReloadManager.ActivitiesReloaded?.Invoke(testActivities);

        // Assert
        eventTriggered.Should().BeTrue();
        receivedActivities.Should().HaveCount(1);
    }

    [Fact]
    public void CreateActivityDelegate_ShouldHandleVariousSignatures()
    {
        // This test verifies the delegate creation logic that was mentioned in the system reminder
        
        // Arrange
        var voidMethod = typeof(TestActivityMethods).GetMethod(nameof(TestActivityMethods.VoidActivity));
        var stringMethod = typeof(TestActivityMethods).GetMethod(nameof(TestActivityMethods.StringActivity));
        var asyncMethod = typeof(TestActivityMethods).GetMethod(nameof(TestActivityMethods.AsyncActivity));

        // Act & Assert
        voidMethod.Should().NotBeNull();
        stringMethod.Should().NotBeNull();
        asyncMethod.Should().NotBeNull();
        
        // The methods should be discoverable by the activity loader
        var activities = ActivityLoader.LoadActivitiesFromAssemblies(Mock.Of<ILogger>());
        activities.Should().NotBeNull();
    }

    [Fact]
    public void ActivityLoader_ShouldHandleMultipleSubscriptions()
    {
        // Arrange
        var eventCount = 0;
        var handler1 = new Action<IEnumerable<Delegate>>(_ => eventCount++);
        var handler2 = new Action<IEnumerable<Delegate>>(_ => eventCount++);

        _activityLoader.ActivitiesChanged += handler1;
        _activityLoader.ActivitiesChanged += handler2;

        // Act
        _activityLoader.HotReloadManager.ActivitiesReloaded?.Invoke(new List<Delegate>());

        // Assert
        eventCount.Should().Be(2, "Both event handlers should be called");

        // Cleanup
        _activityLoader.ActivitiesChanged -= handler1;
        _activityLoader.ActivitiesChanged -= handler2;
    }

    [Fact]
    public void Dispose_ShouldCleanupProperly()
    {
        // Arrange & Act
        _activityLoader.Dispose();

        // Assert - Should not throw
        var act = () => _activityLoader.Dispose();
        act.Should().NotThrow("Multiple dispose calls should be safe");
    }

    [Fact]
    public async Task ConcurrentActivityReloads_ShouldNotCauseRaceConditions()
    {
        // Arrange
        var eventCount = 0;
        var lockObject = new object();
        
        _activityLoader.ActivitiesChanged += activities =>
        {
            lock (lockObject)
            {
                eventCount++;
            }
        };

        var tasks = new List<Task>();

        // Act - Trigger multiple concurrent reloads
        for (int i = 0; i < 10; i++)
        {
            tasks.Add(Task.Run(() => 
            {
                _activityLoader.HotReloadManager.ActivitiesReloaded?.Invoke(new List<Delegate>());
            }));
        }

        await Task.WhenAll(tasks);

        // Assert
        eventCount.Should().Be(10, "All concurrent events should be handled");
    }

    public void Dispose()
    {
        _activityLoader?.Dispose();
    }
}

// Test activity methods for testing delegate creation
public static class TestActivityMethods
{
    [Activity]
    public static void VoidActivity()
    {
        // Void activity for testing
    }

    [Activity]
    public static string StringActivity(string input)
    {
        return $"Processed: {input}";
    }

    [Activity]
    public static async Task<string> AsyncActivity(string input)
    {
        await Task.Delay(1);
        return $"Async processed: {input}";
    }

    [Activity]
    public static async Task<bool> ComplexActivity(string input, int count, bool flag)
    {
        await Task.Delay(1);
        return input.Length > count && flag;
    }
}